<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://gyurania.github.io/</id><title>gyurania</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2023-01-01T14:31:16+09:00</updated> <author> <name>gyurania</name> <uri>https://gyurania.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://gyurania.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://gyurania.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator> <rights> © 2023 gyurania </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[BOJ] 18405번 경쟁적 전염 (Java/BFS)</title><link href="https://gyurania.github.io/posts/boj-18405/" rel="alternate" type="text/html" title="[BOJ] 18405번 경쟁적 전염 (Java/BFS)" /><published>2022-06-30T12:00:00+09:00</published> <updated>2022-06-30T12:00:00+09:00</updated> <id>https://gyurania.github.io/posts/boj-18405/</id> <content src="https://gyurania.github.io/posts/boj-18405/" /> <author> <name>gyurania</name> </author> <category term="Problem Solving" /> <category term="BOJ" /> <summary> 문제 백준 18405번 경쟁적 전염 풀이 바이러스의 위치와 번호를 저장하기 위한 Virus 클래스를 정의합니다. 이때 바이러스 번호를 오름차순으로 정렬하기 위해 Comparable 인터페이스를 사용합니다. 주어진 시험관의 정보를 입력받습니다. 바이러스가 있을 경우 해당 바이러스의 번호와 좌표를 virus 리스트에 추가합니다. 바이러스는 작은 번호부터 순서대로 증식하므로 virus 배열을 바이러스 번호 기준으로 정렬해줍니다. 정렬된 바이러스 리스트를 queue에 삽입합니다. BFS를 통해 S초 동안 바이러스를 증식시키고, (X, Y) 좌표의 바이러스 번호를 출력합니다. 소스 코드 import java.i... </summary> </entry> <entry><title>[BOJ] 14391번 종이 조각 (Java/DFS)</title><link href="https://gyurania.github.io/posts/boj-14391/" rel="alternate" type="text/html" title="[BOJ] 14391번 종이 조각 (Java/DFS)" /><published>2022-06-29T21:00:00+09:00</published> <updated>2022-07-01T23:32:27+09:00</updated> <id>https://gyurania.github.io/posts/boj-14391/</id> <content src="https://gyurania.github.io/posts/boj-14391/" /> <author> <name>gyurania</name> </author> <category term="Problem Solving" /> <category term="BOJ" /> <summary> 문제 백준 14391번 종이 조각 풀이 DFS를 통해 check 배열에 가로, 세로를 표시합니다. 가로로 이어지는 숫자는 true, 세로로 이어지는 숫자는 false 입니다. check 배열을 전부 탐색하면 getSum 함수를 호출해 각 경우의 합의 구합니다. 최대 합과 비교하여 값을 갱신합니다. 소스 코드 import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int N, M, arr[][]; static boolean check[][]; static int res; public static... </summary> </entry> <entry><title>[Java] Garbage Collection</title><link href="https://gyurania.github.io/posts/gc/" rel="alternate" type="text/html" title="[Java] Garbage Collection" /><published>2022-06-29T09:00:00+09:00</published> <updated>2022-06-29T09:00:00+09:00</updated> <id>https://gyurania.github.io/posts/gc/</id> <content src="https://gyurania.github.io/posts/gc/" /> <author> <name>gyurania</name> </author> <category term="Programming Language" /> <category term="Java" /> <summary> Garbage Collection Garbage Collection(GC)은 JVM 상에서 더 이상 사용되지 않는 데이터가 할당되어 있는 메모리를 해제시켜주는 장치입니다. 또한 자동으로 동작하기 때문에 개발자가 메모리 관리를 할 필요가 없습니다. 주로 관리하는 대상은 Heap 영역 내의 객체 중에서 참조되지 않은 데이터입니다. 참조되어 있는지에 대한 개념을 reachability라 하고, 참조되고 있으면 reachable, 참조되고 있지 않으면 unreachable이라고 합니다. 또한 reachable로 인식되게 만들어주는 JVM Runtime Area들을 root set이라고 합니다. GC는 unreachable한 객체들을 garbage라고 인식합니다. Heap 영역 내부의 객체들은 Met... </summary> </entry> <entry><title>[BOJ] 17141번 연구소 2 (Java/Combination/BFS)</title><link href="https://gyurania.github.io/posts/boj-17141/" rel="alternate" type="text/html" title="[BOJ] 17141번 연구소 2 (Java/Combination/BFS)" /><published>2022-06-28T20:00:00+09:00</published> <updated>2022-06-29T21:23:21+09:00</updated> <id>https://gyurania.github.io/posts/boj-17141/</id> <content src="https://gyurania.github.io/posts/boj-17141/" /> <author> <name>gyurania</name> </author> <category term="Problem Solving" /> <category term="BOJ" /> <summary> 문제 백준 17141번 연구소 2 풀이 comb 함수를 이용해 초기에 바이러스를 놓을 칸을 선택합니다. copy_map에서 벽은 -1, 초기에 바이러스를 위치시킨 곳은 -10으로 지정합니다. BFS 함수로 바이러스가 퍼지는데 걸리는 시간을 계산하여 copy_map에 저장합니다. 빈 칸이 있는지 확인하고, 없으면 최소 시간을 계산합니다. 소스 코드 import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; import java.util... </summary> </entry> <entry><title>[BOJ] 17298번 오큰수 (Java/Stack)</title><link href="https://gyurania.github.io/posts/boj-17298/" rel="alternate" type="text/html" title="[BOJ] 17298번 오큰수 (Java/Stack)" /><published>2022-06-28T17:00:00+09:00</published> <updated>2022-06-30T18:47:19+09:00</updated> <id>https://gyurania.github.io/posts/boj-17298/</id> <content src="https://gyurania.github.io/posts/boj-17298/" /> <author> <name>gyurania</name> </author> <category term="Problem Solving" /> <category term="BOJ" /> <summary> 문제 백준 17298번 오큰수 풀이1 해당하는 인덱스에 오큰수를 출력하기 위해 인덱스와 숫자값을 가지는 Element 클래스를 이용합니다. 오큰수가 없을 경우 -1을 출력해야 하므로, 오큰수를 저장하는 res 배열의 원소를 전부 -1로 초기화합니다. 스택의 top보다 현재 입력받는 수가 크면, 현재 수는 스택의 top의 오큰수입니다. 스택의 top의 인덱스에 현재 수(=오큰수)를 저장하고, pop하여 제거합니다. 스택이 비어있지 않고, 현재 수가 스택의 top보다 크면 3, 4번 과정을 반복합니다. 스택에 현재 수를 push 합니다. 모든 수를 입력받으면 for문이 종료되고, res 배열에서 오큰수를 하나씩 출력합니다. 소스 코드 import java.io.Bu... </summary> </entry> </feed>
