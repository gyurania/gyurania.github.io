---
title: "[Sort] 정렬 알고리즘(nlogn)"
date: 2022-06-22 01:40:00 +09:00
categories: [Algorithm, Sort]
tags: [sort, heap, merge, quick]
mermaid: true
use_math: true
---

### 목차

- [사전지식](#사전지식)
- [O(nlogn) 정렬](#onlogn-정렬)

### 사전지식

- [시간복잡도](#시간복잡도)
- [Big-O 표기법](#big-o-표기법)
- [안정 정렬 / 불안정 정렬](#안정정렬과-불안정정렬)
- [참조 지역성 원리](#참조지역성-원리)

#### 시간복잡도

알고리즘의 시간 복잡도란 '입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마나 소요되는가?'를 의미한다.  
효율적인 알고리즘이란 입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘이라고 할 수 있다.  
시간 복잡도는 주로 Big-O 표기법을 사용해 나타낸다.

#### Big-O 표기법

Big-O(빅오) 표기법을 사용하면 프로그램이 실행되는 과정에서 소요되는 가장 최악의 시간까지 고려할 수 있다.

따라서 평균과 가까운 성능으로 예측하기 용이하므로 Big-O 표기법을 가장 많이 사용한다.
![BigO](/assets/img/2022-06-22/BigO.png)
_여러 함수의 증가율 비교_

#### 안정정렬과 불안정정렬

안정 정렬과 불안정 정렬의 구분은 입력에 중복된 값이 있을 경우 어떻게 정렬하는가에 따라 나뉜다.

- 안정 정렬: 중복된 값이 있을 경우 입력 순서와 동일하게 정렬됨
  - Ex) 삽입 정렬, 버블 정렬, 병합 정렬
- 불안정 정렬: 중복된 값이 있을 경우 입력 순서와 관계없이 무작위로 정렬됨
  - Ex) 선택 정렬, 퀵 정렬, 힙 정렬

#### 참조지역성 원리

$O(nlogn)$ 시간 복잡도 알고리즘의 실제 동작 시간은 $C × nlogn + α$로 나타낼 수 있는데, 이때 $C$에 따라 같은 $nlogn$이더라도 시간 차이가 발생한다.

이 $C$에 영향을 미치는 요소로 '알고리즘이 참조 지역성(Locality of Reference) 원리를 얼마나 잘 만족하는가'가 있다.

참조 지역성 원리란, CPU가 미래에 원하는 데이터를 예측하여 속도가 빠른 장치인 캐시 메모리에 담아놓는데, 이때의 예측률을 높이기 위해 사용하는 원리이다. 쉽게 말하자면, 최근에 참조한 메모리나 그 메모리와 인접한 메모리를 다시 참조할 확률이 높다는 이론을 기반으로 캐시 메모리에 담아놓는 것이다.

메모리를 연속으로 읽는 작업은 캐시 메모리에서 읽어오기에 빠른 반면, 무작위로 읽는 작업은 메인 메모리에서 읽어오기에 속도의 차이가 있다.

### O(nlogn) 정렬
